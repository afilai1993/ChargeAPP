import 'dart:convert';
import 'dart:math';

import '../event/logging_event.dart';
import '../level/level.dart';
import 'ansi_color.dart';
import 'layout.dart';

class PrettyLayout implements Layout {
  static const topLeftCorner = '‚îå';
  static const bottomLeftCorner = '‚îî';
  static const middleCorner = '‚îú';
  static const verticalLine = '‚îÇ';
  static const doubleDivider = '‚îÄ';
  static const singleDivider = '‚îÑ';

  static final levelColors = {
    Level.debug: AnsiColor.none(),
    Level.info: AnsiColor.fg(12),
    Level.warn: AnsiColor.fg(208),
    Level.error: AnsiColor.fg(196),
  };

  static final levelEmojis = {
    Level.debug: 'üêõ ',
    Level.info: 'üí° ',
    Level.warn: '‚ö†Ô∏è ',
    Level.error: '‚õî ',
  };
  final int stackTraceBeginIndex;
  final int methodCount;
  final int errorMethodCount;
  final int lineLength;
  final bool colors;
  final bool printEmojis;
  final bool printTime;
  final int limitLength;
  final bool showLogName;
  final bool showLevelName;
  final Map<Level, bool> excludeBox;
  final bool noBoxingByDefault;
  late final Map<Level, bool> includeBox;

  /// Matches a stacktrace line as generated on Android/iOS devices.
  /// For example:
  /// #1      Logger.logger (package:logger/src/gplogger.dart:115:29)
  static final _deviceStackTraceRegex =
      RegExp(r'#[0-9]+[\s]+(.+) \(([^\s]+)\)');

  /// Matches a stacktrace line as generated by Flutter web.
  /// For example:
  /// packages/logger/src/printers/pretty_printer.dart 91:37
  static final _webStackTraceRegex =
      RegExp(r'^((packages|dart-sdk)\/[^\s]+\/)');

  /// Matches a stacktrace line as generated by browser Dart.
  /// For example:
  /// dart:sdk_internal
  /// package:logger/src/gplogger.dart
  static final _browserStackTraceRegex =
      RegExp(r'^(?:package:)?(dart:[^\s]+|[^\s]+)');

  String _topBorder = '';
  String _middleBorder = '';
  String _bottomBorder = '';

  PrettyLayout({
    this.showLogName = false,
    this.showLevelName = false,
    this.stackTraceBeginIndex = 0,
    this.methodCount = 2,
    this.errorMethodCount = 8,
    this.lineLength = 120,
    this.colors = true,
    this.printEmojis = true,
    this.printTime = false,
    this.limitLength = 800,
    this.excludeBox = const {},
    this.noBoxingByDefault = false,
  }) {
    var doubleDividerLine = StringBuffer();
    var singleDividerLine = StringBuffer();
    for (var i = 0; i < lineLength - 1; i++) {
      doubleDividerLine.write(doubleDivider);
      singleDividerLine.write(singleDivider);
    }

    _topBorder = '$topLeftCorner$doubleDividerLine';
    _middleBorder = '$middleCorner$singleDividerLine';
    _bottomBorder = '$bottomLeftCorner$doubleDividerLine';

    includeBox = {};
    for (var l in Level.values) {
      includeBox[l] = !noBoxingByDefault;
    }
    excludeBox.forEach((k, v) => includeBox[k] = !v);
  }

  @override
  List<String> log(LoggingEvent event) {
    var messageStr = stringifyMessage(event.message);
    String? stackTraceStr;
    if (event.stackTrace == null) {
      if (methodCount > 0) {
        stackTraceStr = formatStackTrace(StackTrace.current, methodCount);
      }
    } else if (errorMethodCount > 0) {
      stackTraceStr = formatStackTrace(event.stackTrace, errorMethodCount);
    }
    var errorStr = event.error?.toString();

    String? timeStr;
    if (printTime) {
      timeStr = getTime();
    }
    return _formatAndPrint(
      getLabel(event),
      event.level,
      messageStr,
      timeStr,
      errorStr,
      stackTraceStr,
    );
  }

  String getLabel(LoggingEvent event) {
    final sb = StringBuffer();
    if (showLogName) {
      final name = event.name;
      if (name != null && name.isNotEmpty) {
        sb.write("[$name]");
      }
    }
    if (showLevelName) {
      final levelLabel = getLevelLabel(event);
      if (levelLabel.isNotEmpty) {
        sb.write("[$levelLabel]");
      }
    }
    return sb.toString();
  }

  String getLevelLabel(LoggingEvent event) {
    switch (event.level) {
      case Level.warn:
        return "WARN";
      case Level.error:
        return "ERROR";
      case Level.info:
        return "INFO";
      case Level.debug:
        return "DEBUG";
      case Level.none:
        return "";
    }
  }

  String stringifyMessage(dynamic message) {
    final finalMessage = message is Function ? message() : message;
    if (finalMessage is Map || finalMessage is Iterable) {
      var encoder = JsonEncoder.withIndent('  ', toEncodableFallback);
      return encoder.convert(finalMessage);
    } else {
      return finalMessage.toString();
    }
  }

  Object toEncodableFallback(dynamic object) {
    return object.toString();
  }

  String? formatStackTrace(StackTrace? stackTrace, int methodCount) {
    var lines = stackTrace.toString().split('\n');
    if (stackTraceBeginIndex > 0 && stackTraceBeginIndex < lines.length - 1) {
      lines = lines.sublist(stackTraceBeginIndex);
    }
    var formatted = <String>[];
    var count = 0;
    for (var line in lines) {
      if (_discardDeviceStacktraceLine(line) ||
          _discardWebStacktraceLine(line) ||
          _discardBrowserStacktraceLine(line) ||
          line.isEmpty) {
        continue;
      }
      formatted.add('#$count   ${line.replaceFirst(RegExp(r'#\d+\s+'), '')}');
      if (++count == methodCount) {
        break;
      }
    }

    if (formatted.isEmpty) {
      return null;
    } else {
      return formatted.join('\n');
    }
  }

  bool _discardDeviceStacktraceLine(String line) {
    var match = _deviceStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }
    //return match.group(2)!.startsWith('package:logger');
    return match.group(2)!.contains('package:logger');
  }

  bool _discardWebStacktraceLine(String line) {
    var match = _webStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }
    // return match.group(1)!.startsWith('packages/logger') ||
    //     match.group(1)!.startsWith('dart-sdk/lib');

    return match.group(1)!.contains('package:logger') ||
        match.group(1)!.startsWith('dart-sdk/lib');
  }

  bool _discardBrowserStacktraceLine(String line) {
    var match = _browserStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }
    // return match.group(1)!.startsWith('package:logger') ||
    //     match.group(1)!.startsWith('dart:');

    return match.group(1)!.contains('package:logger') ||
        match.group(1)!.startsWith('dart:');
  }

  String getTime() {
    final date = DateTime.now();
    return "${date.year}-${date.month}-${date.day} ${date.hour}:${date.minute}:${date.second}:${date.millisecond}";
  }

  AnsiColor _getLevelColor(Level level) {
    if (colors) {
      return levelColors[level]!;
    } else {
      return AnsiColor.none();
    }
  }

  String _getEmoji(Level level) {
    if (printEmojis) {
      return levelEmojis[level]!;
    } else {
      return '';
    }
  }

  List<String> _formatAndPrint(
    String label,
    Level level,
    String message,
    String? time,
    String? error,
    String? stacktrace,
  ) {
    // This code is non trivial and a type annotation here helps understanding.
    // ignore: omit_local_variable_types
    List<String> buffer = [];
    var verticalLineAtLevel =
        (includeBox[level]!) ? (label + verticalLine) : label;
    var color = _getLevelColor(level);
    if (includeBox[level]!) buffer.add(color(label + _topBorder));

    if (error != null) {
      var errorColor = _getLevelColor(Level.error);
      for (var line in error.split('\n')) {
        buffer.add(
          color(verticalLineAtLevel) +
              errorColor.resetForeground +
              errorColor(line) +
              errorColor.resetBackground,
        );
      }
      if (includeBox[level]!) buffer.add(color(label + _middleBorder));
    }

    if (stacktrace != null) {
      for (var line in stacktrace.split('\n')) {
        buffer.add(color('$verticalLineAtLevel$line'));
      }
      if (includeBox[level]!) buffer.add(color(label + _middleBorder));
    }

    if (time != null) {
      buffer.add(color('$verticalLineAtLevel$time'));
      if (includeBox[level]!) buffer.add(color(label + _middleBorder));
    }

    var emoji = _getEmoji(level);
    for (var line in message.split('\n')) {
      final segments = segmentMessage(line);
      for (int index = 0; index < segments.length; index++) {
        if (index == 0) {
          buffer.add(color("$verticalLineAtLevel$emoji${segments[index]}"));
        } else {
          buffer.add(color("$verticalLineAtLevel${segments[index]}"));
        }
      }
    }
    if (includeBox[level]!) buffer.add(color(label + _bottomBorder));
    return buffer;
  }

  List<String> segmentMessage(String line) {
    List<String> result = [];
    if (line.length <= limitLength) {
      result.add(line);
    } else {
      int segmentLine = 0;
      int start;
      int end;
      final int length = line.length;
      for (;;) {
        if (segmentLine * limitLength >= length) {
          break;
        }
        start = segmentLine * limitLength;
        end = start + min(length - start, limitLength);
        result.add(line.substring(start, end));
        if (end >= length) {
          break;
        }
        segmentLine++;
      }
    }
    return result;
  }
}
